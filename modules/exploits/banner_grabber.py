#!/usr/bin/env python3
"""
RED Team Toolkit - Banner Grabber Module
Service fingerprinting and banner grabbing
"""

import socket
import ssl
import threading
import sys
from datetime import datetime

class BannerGrabber:
    def __init__(self):
        self.results = {}
        self.lock = threading.Lock()
        
    def grab_banner(self, target, port, timeout=3):
        """Grab banner from a specific port"""
        try:
            # Create socket
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            
            # Connect to target
            result = sock.connect_ex((target, port))
            if result != 0:
                sock.close()
                return None
            
            banner = ""
            
            # Special handling for different services
            if port == 80:  # HTTP
                sock.send(b"GET / HTTP/1.1\r\nHost: " + target.encode() + b"\r\n\r\n")
                banner = sock.recv(1024).decode('utf-8', errors='ignore')
                
            elif port == 443:  # HTTPS
                try:
                    context = ssl.create_default_context()
                    context.check_hostname = False
                    context.verify_mode = ssl.CERT_NONE
                    
                    with context.wrap_socket(sock, server_hostname=target) as ssock:
                        ssock.send(b"GET / HTTP/1.1\r\nHost: " + target.encode() + b"\r\n\r\n")
                        banner = ssock.recv(1024).decode('utf-8', errors='ignore')
                except:
                    banner = "SSL/TLS service detected"
                    
            elif port == 21:  # FTP
                banner = sock.recv(1024).decode('utf-8', errors='ignore')
                
            elif port == 22:  # SSH
                banner = sock.recv(1024).decode('utf-8', errors='ignore')
                
            elif port == 25:  # SMTP
                banner = sock.recv(1024).decode('utf-8', errors='ignore')
                
            elif port == 110:  # POP3
                banner = sock.recv(1024).decode('utf-8', errors='ignore')
                
            elif port == 143:  # IMAP
                banner = sock.recv(1024).decode('utf-8', errors='ignore')
                
            elif port == 3389:  # RDP
                banner = "RDP service detected"
                
            else:  # Generic banner grab
                try:
                    banner = sock.recv(1024).decode('utf-8', errors='ignore')
                except:
                    banner = "Service detected (no banner)"
            
            sock.close()
            
            with self.lock:
                self.results[port] = {
                    'banner': banner.strip(),
                    'service': self.identify_service(port, banner)
                }
            
            return banner.strip()
            
        except Exception as e:
            return None
    
    def identify_service(self, port, banner):
        """Identify service based on port and banner"""
        # Common service identification
        services = {
            21: "FTP", 22: "SSH", 23: "Telnet", 25: "SMTP", 53: "DNS",
            80: "HTTP", 110: "POP3", 143: "IMAP", 443: "HTTPS", 993: "IMAPS",
            995: "POP3S", 3389: "RDP", 5432: "PostgreSQL", 3306: "MySQL"
        }
        
        base_service = services.get(port, "Unknown")
        
        if not banner:
            return base_service
        
        banner_lower = banner.lower()
        
        # Detailed service identification based on banner
        if "apache" in banner_lower:
            return f"{base_service} (Apache)"
        elif "nginx" in banner_lower:
            return f"{base_service} (Nginx)"
        elif "microsoft-iis" in banner_lower:
            return f"{base_service} (IIS)"
        elif "openssh" in banner_lower:
            return f"{base_service} (OpenSSH)"
        elif "microsoft" in banner_lower and port == 3389:
            return f"{base_service} (Microsoft Terminal Services)"
        elif "mysql" in banner_lower:
            return f"{base_service} (MySQL)"
        elif "postgresql" in banner_lower:
            return f"{base_service} (PostgreSQL)"
        elif "ftp" in banner_lower:
            return f"{base_service} (FTP Server)"
        
        return base_service
    
    def scan_multiple_ports(self, target, ports):
        """Grab banners from multiple ports"""
        print(f"\nüîç Banner Grabbing from {target}")
        print(f"üìä Scanning {len(ports)} ports")
        print(f"‚è∞ Started at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("-" * 50)
        
        # Reset results
        self.results = {}
        
        # Create threads for each port
        threads = []
        for port in ports:
            thread = threading.Thread(target=self.grab_banner, args=(target, port))
            threads.append(thread)
            thread.start()
        
        # Wait for all threads to complete
        for thread in threads:
            thread.join()
        
        # Display results
        self.display_results(target)
    
    def display_results(self, target):
        """Display banner grabbing results"""
        print(f"\nüìä Banner Grabbing Results for {target}")
        print("=" * 60)
        
        if self.results:
            print(f"\n‚úÖ Services Found ({len(self.results)}):")
            print(f"{'Port':<6} {'Service':<20} {'Banner'}")
            print("-" * 60)
            
            for port in sorted(self.results.keys()):
                result = self.results[port]
                service = result['service']
                banner = result['banner'][:40] + "..." if len(result['banner']) > 40 else result['banner']
                print(f"{port:<6} {service:<20} {banner}")
                
                # Show full banner if it's interesting
                if len(result['banner']) > 40 and any(keyword in result['banner'].lower() 
                    for keyword in ['server:', 'version', 'apache', 'nginx', 'openssh']):
                    print(f"       Full banner: {result['banner']}")
        else:
            print("\n‚ùå No banners retrieved")
        
        print(f"\n‚è∞ Completed at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

def main():
    """Main banner grabber interface"""
    grabber = BannerGrabber()
    
    print("\nüîç BANNER GRABBER")
    print("=" * 30)
    print("‚ö†Ô∏è  Use only on systems you own or have permission to test")
    print()
    
    while True:
        print("\nOptions:")
        print("1. Grab banner from single port")
        print("2. Grab banners from common ports")
        print("3. Grab banners from custom port list")
        print("0. Back to main menu")
        
        choice = input("\nSelect option: ").strip()
        
        if choice == '1':
            target = input("Enter target IP/hostname: ").strip()
            if not target:
                print("‚ùå Target is required")
                continue
            
            try:
                port = int(input("Enter port (1-65535): "))
                if port < 1 or port > 65535:
                    print("‚ùå Invalid port number")
                    continue
                
                print(f"\nüîç Grabbing banner from {target}:{port}")
                banner = grabber.grab_banner(target, port)
                
                if banner:
                    service = grabber.identify_service(port, banner)
                    print(f"‚úÖ Service: {service}")
                    print(f"üìÑ Banner: {banner}")
                else:
                    print(f"‚ùå No banner received from {target}:{port}")
                    
            except ValueError:
                print("‚ùå Invalid port number")
                continue
                
        elif choice == '2':
            target = input("Enter target IP/hostname: ").strip()
            if not target:
                print("‚ùå Target is required")
                continue
            
            common_ports = [21, 22, 25, 53, 80, 110, 143, 443, 993, 995, 3389]
            grabber.scan_multiple_ports(target, common_ports)
            
        elif choice == '3':
            target = input("Enter target IP/hostname: ").strip()
            if not target:
                print("‚ùå Target is required")
                continue
            
            ports_input = input("Enter ports (comma-separated, e.g., 80,443,22): ").strip()
            if not ports_input:
                print("‚ùå Ports are required")
                continue
            
            try:
                ports = [int(p.strip()) for p in ports_input.split(',')]
                if any(p < 1 or p > 65535 for p in ports):
                    print("‚ùå Invalid port number(s)")
                    continue
                
                grabber.scan_multiple_ports(target, ports)
                
            except ValueError:
                print("‚ùå Invalid port format")
                continue
                
        elif choice == '0':
            break
        else:
            print("‚ùå Invalid option")

if __name__ == "__main__":
    main()
