#!/usr/bin/env python3
"""
RED Team Toolkit - Web Vulnerability Scanner
Basic web application security testing
"""

import requests
import urllib.parse
from datetime import datetime
import threading
import sys

class WebScanner:
    def __init__(self):
        self.vulnerabilities = []
        self.lock = threading.Lock()
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'RED-Team-Toolkit/3.0 (Security Scanner)'
        })
        
    def test_sql_injection(self, url):
        """Test for basic SQL injection vulnerabilities"""
        print("üîç Testing for SQL Injection...")
        
        # Common SQL injection payloads
        payloads = [
            "'", "\"", "' OR '1'='1", "\" OR \"1\"=\"1", 
            "' OR 1=1--", "\" OR 1=1--", "'; DROP TABLE users--",
            "1' UNION SELECT NULL--", "1\" UNION SELECT NULL--"
        ]
        
        # Test GET parameters
        parsed_url = urllib.parse.urlparse(url)
        if parsed_url.query:
            params = urllib.parse.parse_qs(parsed_url.query)
            
            for param in params:
                for payload in payloads:
                    test_params = params.copy()
                    test_params[param] = [payload]
                    test_query = urllib.parse.urlencode(test_params, doseq=True)
                    test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{test_query}"
                    
                    try:
                        response = self.session.get(test_url, timeout=5)
                        
                        # Check for SQL error messages
                        error_patterns = [
                            "sql syntax", "mysql_fetch", "ora-", "postgresql",
                            "sqlite_", "odbc_", "jdbc_", "error in your sql syntax",
                            "warning: mysql", "valid mysql result", "mysqlclient",
                        ]
                        
                        response_lower = response.text.lower()
                        for pattern in error_patterns:
                            if pattern in response_lower:
                                with self.lock:
                                    self.vulnerabilities.append({
                                        'type': 'SQL Injection',
                                        'severity': 'High',
                                        'parameter': param,
                                        'payload': payload,
                                        'url': test_url,
                                        'evidence': f"SQL error pattern found: {pattern}"
                                    })
                                print(f"   ‚ö†Ô∏è  Potential SQL injection in parameter: {param}")
                                break
                                
                    except requests.RequestException:
                        continue
    
    def test_xss(self, url):
        """Test for Cross-Site Scripting (XSS) vulnerabilities"""
        print("üîç Testing for XSS...")
        
        # XSS payloads
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>",
            "'\"><script>alert('XSS')</script>",
        ]
        
        # Test GET parameters
        parsed_url = urllib.parse.urlparse(url)
        if parsed_url.query:
            params = urllib.parse.parse_qs(parsed_url.query)
            
            for param in params:
                for payload in payloads:
                    test_params = params.copy()
                    test_params[param] = [payload]
                    test_query = urllib.parse.urlencode(test_params, doseq=True)
                    test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{test_query}"
                    
                    try:
                        response = self.session.get(test_url, timeout=5)
                        
                        # Check if payload is reflected in response
                        if payload in response.text:
                            with self.lock:
                                self.vulnerabilities.append({
                                    'type': 'Cross-Site Scripting (XSS)',
                                    'severity': 'Medium',
                                    'parameter': param,
                                    'payload': payload,
                                    'url': test_url,
                                    'evidence': 'Payload reflected in response'
                                })
                            print(f"   ‚ö†Ô∏è  Potential XSS in parameter: {param}")
                            
                    except requests.RequestException:
                        continue
    
    def test_directory_traversal(self, url):
        """Test for directory traversal vulnerabilities"""
        print("üîç Testing for Directory Traversal...")
        
        # Directory traversal payloads
        payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "....//....//....//etc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
        ]
        
        parsed_url = urllib.parse.urlparse(url)
        if parsed_url.query:
            params = urllib.parse.parse_qs(parsed_url.query)
            
            for param in params:
                for payload in payloads:
                    test_params = params.copy()
                    test_params[param] = [payload]
                    test_query = urllib.parse.urlencode(test_params, doseq=True)
                    test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{test_query}"
                    
                    try:
                        response = self.session.get(test_url, timeout=5)
                        
                        # Check for file content indicators
                        indicators = [
                            "root:x:", "daemon:x:", "[boot loader]", 
                            "# Copyright", "localhost", "127.0.0.1"
                        ]
                        
                        for indicator in indicators:
                            if indicator in response.text:
                                with self.lock:
                                    self.vulnerabilities.append({
                                        'type': 'Directory Traversal',
                                        'severity': 'High',
                                        'parameter': param,
                                        'payload': payload,
                                        'url': test_url,
                                        'evidence': f'File content indicator found: {indicator}'
                                    })
                                print(f"   ‚ö†Ô∏è  Potential directory traversal in parameter: {param}")
                                break
                                
                    except requests.RequestException:
                        continue
    
    def check_security_headers(self, url):
        """Check for missing security headers"""
        print("üîç Checking Security Headers...")
        
        try:
            response = self.session.get(url, timeout=10)
            headers = response.headers
            
            # Important security headers
            security_headers = {
                'X-Content-Type-Options': 'nosniff',
                'X-Frame-Options': ['DENY', 'SAMEORIGIN'],
                'X-XSS-Protection': '1; mode=block',
                'Strict-Transport-Security': None,
                'Content-Security-Policy': None,
                'Referrer-Policy': None
            }
            
            missing_headers = []
            for header, expected in security_headers.items():
                if header not in headers:
                    missing_headers.append(header)
                    with self.lock:
                        self.vulnerabilities.append({
                            'type': 'Missing Security Header',
                            'severity': 'Low',
                            'parameter': header,
                            'payload': 'N/A',
                            'url': url,
                            'evidence': f'Missing {header} header'
                        })
            
            if missing_headers:
                print(f"   ‚ö†Ô∏è  Missing security headers: {', '.join(missing_headers)}")
            else:
                print("   ‚úÖ All important security headers present")
                
        except requests.RequestException as e:
            print(f"   ‚ùå Error checking headers: {e}")
    
    def scan_url(self, url):
        """Perform comprehensive scan on a URL"""
        print(f"\nüîç Web Vulnerability Scan")
        print(f"üéØ Target: {url}")
        print(f"‚è∞ Started at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("-" * 60)
        
        # Reset vulnerabilities
        self.vulnerabilities = []
        
        # Verify URL is accessible
        try:
            response = self.session.get(url, timeout=10)
            print(f"‚úÖ Target accessible (Status: {response.status_code})")
        except requests.RequestException as e:
            print(f"‚ùå Cannot access target: {e}")
            return
        
        # Run tests
        self.test_sql_injection(url)
        self.test_xss(url)
        self.test_directory_traversal(url)
        self.check_security_headers(url)
        
        # Display results
        self.display_results(url)
    
    def display_results(self, url):
        """Display scan results"""
        print(f"\nüìä Vulnerability Scan Results for {url}")
        print("=" * 70)
        
        if self.vulnerabilities:
            # Group by severity
            high_vulns = [v for v in self.vulnerabilities if v['severity'] == 'High']
            medium_vulns = [v for v in self.vulnerabilities if v['severity'] == 'Medium']
            low_vulns = [v for v in self.vulnerabilities if v['severity'] == 'Low']
            
            if high_vulns:
                print(f"\nüî¥ HIGH SEVERITY ({len(high_vulns)}):")
                for vuln in high_vulns:
                    print(f"   ‚Ä¢ {vuln['type']} in {vuln['parameter']}")
                    print(f"     Evidence: {vuln['evidence']}")
            
            if medium_vulns:
                print(f"\nüü° MEDIUM SEVERITY ({len(medium_vulns)}):")
                for vuln in medium_vulns:
                    print(f"   ‚Ä¢ {vuln['type']} in {vuln['parameter']}")
                    print(f"     Evidence: {vuln['evidence']}")
            
            if low_vulns:
                print(f"\nüü¢ LOW SEVERITY ({len(low_vulns)}):")
                for vuln in low_vulns:
                    print(f"   ‚Ä¢ {vuln['type']}: {vuln['parameter']}")
            
            print(f"\nüìà Summary:")
            print(f"   Total vulnerabilities: {len(self.vulnerabilities)}")
            print(f"   High: {len(high_vulns)}, Medium: {len(medium_vulns)}, Low: {len(low_vulns)}")
            
        else:
            print("\n‚úÖ No vulnerabilities detected")
        
        print(f"\n‚è∞ Completed at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("\n‚ö†Ô∏è  Note: This is a basic scan. Professional tools may find additional issues.")

def main():
    """Main web scanner interface"""
    scanner = WebScanner()
    
    print("\nüåê WEB VULNERABILITY SCANNER")
    print("=" * 40)
    print("‚ö†Ô∏è  Use only on websites you own or have permission to test")
    print()
    
    while True:
        print("\nOptions:")
        print("1. Scan URL for vulnerabilities")
        print("2. Test specific vulnerability type")
        print("0. Back to main menu")
        
        choice = input("\nSelect option: ").strip()
        
        if choice == '1':
            url = input("Enter target URL (e.g., http://example.com/page?id=1): ").strip()
            if not url:
                print("‚ùå URL is required")
                continue
            
            if not url.startswith(('http://', 'https://')):
                url = 'http://' + url
            
            scanner.scan_url(url)
            
        elif choice == '2':
            print("\nVulnerability Types:")
            print("1. SQL Injection")
            print("2. Cross-Site Scripting (XSS)")
            print("3. Directory Traversal")
            print("4. Security Headers")
            
            vuln_choice = input("Select vulnerability type: ").strip()
            url = input("Enter target URL: ").strip()
            
            if not url:
                print("‚ùå URL is required")
                continue
            
            if not url.startswith(('http://', 'https://')):
                url = 'http://' + url
            
            scanner.vulnerabilities = []
            
            if vuln_choice == '1':
                scanner.test_sql_injection(url)
            elif vuln_choice == '2':
                scanner.test_xss(url)
            elif vuln_choice == '3':
                scanner.test_directory_traversal(url)
            elif vuln_choice == '4':
                scanner.check_security_headers(url)
            else:
                print("‚ùå Invalid option")
                continue
            
            scanner.display_results(url)
            
        elif choice == '0':
            break
        else:
            print("‚ùå Invalid option")

if __name__ == "__main__":
    main()
